###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.1.10194/W32 for 8051         16/Apr/2020  14:02:52 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4.0\Pro #
#                          jects\zstack\Samples\SampleApp                     #
#                          _02\Source\SampleApp.c                             #
#    Command line       =  -f "C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4.0 #
#                          \Projects\zstack\Samples\SampleApp                 #
#                          _02\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg" #
#                           (-DCPU32MHZ -DROOT=__near_func -DBLINK_LEDS) -f   #
#                          "C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4.0\Pr #
#                          ojects\zstack\Samples\SampleApp                    #
#                          _02\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg #
#                          " (-DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR    #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          "C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4.0\Pr #
#                          ojects\zstack\Samples\SampleApp                    #
#                          _02\Source\SampleApp.c" -D ZIGBEEPRO -D            #
#                          NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D            #
#                          MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG  #
#                          -lC "C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4. #
#                          0\Projects\zstack\Samples\SampleApp                #
#                          _02\CC2530DB\EndDeviceEB-Pro\List\" -lA "C:\Texas  #
#                          Instruments\ZStack-CC2530-2.3.0-1.4.0\Projects\zst #
#                          ack\Samples\SampleApp _02\CC2530DB\EndDeviceEB-Pro #
#                          \List\" --diag_suppress Pe001,Pa010 -o "C:\Texas   #
#                          Instruments\ZStack-CC2530-2.3.0-1.4.0\Projects\zst #
#                          ack\Samples\SampleApp _02\CC2530DB\EndDeviceEB-Pro #
#                          \Obj\" -e --debug --core=plain --dptr=16,1         #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I "C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4.0 #
#                          \Projects\zstack\Samples\SampleApp _02\CC2530DB\"  #
#                          -I "C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4.0 #
#                          \Projects\zstack\Samples\SampleApp                 #
#                          _02\CC2530DB\..\SOURCE\" -I "C:\Texas              #
#                          Instruments\ZStack-CC2530-2.3.0-1.4.0\Projects\zst #
#                          ack\Samples\SampleApp _02\CC2530DB\..\..\..\ZMAIN\ #
#                          TI2530DB\" -I "C:\Texas Instruments\ZStack-CC2530- #
#                          2.3.0-1.4.0\Projects\zstack\Samples\SampleApp      #
#                          _02\CC2530DB\..\..\..\..\..\COMPONENTS\MT\" -I     #
#                          "C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4.0\Pr #
#                          ojects\zstack\Samples\SampleApp                    #
#                          _02\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INCLUDE #
#                          \" -I "C:\Texas Instruments\ZStack-CC2530-2.3.0-1. #
#                          4.0\Projects\zstack\Samples\SampleApp              #
#                          _02\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TARGET\ #
#                          CC2530EB\" -I "C:\Texas Instruments\ZStack-CC2530- #
#                          2.3.0-1.4.0\Projects\zstack\Samples\SampleApp      #
#                          _02\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MCU\CC #
#                          SOC\" -I "C:\Texas Instruments\ZStack-CC2530-2.3.0 #
#                          -1.4.0\Projects\zstack\Samples\SampleApp           #
#                          _02\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\INCLUD #
#                          E\" -I "C:\Texas Instruments\ZStack-CC2530-2.3.0-1 #
#                          .4.0\Projects\zstack\Samples\SampleApp             #
#                          _02\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF\"  #
#                          -I "C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4.0 #
#                          \Projects\zstack\Samples\SampleApp                 #
#                          _02\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK\" #
#                           -I "C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4. #
#                          0\Projects\zstack\Samples\SampleApp                #
#                          _02\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SEC\" #
#                           -I "C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4. #
#                          0\Projects\zstack\Samples\SampleApp                #
#                          _02\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SAPI\ #
#                          " -I "C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4 #
#                          .0\Projects\zstack\Samples\SampleApp               #
#                          _02\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SYS\" #
#                           -I "C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4. #
#                          0\Projects\zstack\Samples\SampleApp                #
#                          _02\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\" #
#                           -I "C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4. #
#                          0\Projects\zstack\Samples\SampleApp                #
#                          _02\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W\"  #
#                          -I "C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4.0 #
#                          \Projects\zstack\Samples\SampleApp                 #
#                          _02\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\" -I   #
#                          "C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4.0\Pr #
#                          ojects\zstack\Samples\SampleApp                    #
#                          _02\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SA #
#                          DDR\" -I "C:\Texas Instruments\ZStack-CC2530-2.3.0 #
#                          -1.4.0\Projects\zstack\Samples\SampleApp           #
#                          _02\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SD #
#                          ATA\" -I "C:\Texas Instruments\ZStack-CC2530-2.3.0 #
#                          -1.4.0\Projects\zstack\Samples\SampleApp           #
#                          _02\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCLUDE #
#                          \" -I "C:\Texas Instruments\ZStack-CC2530-2.3.0-1. #
#                          4.0\Projects\zstack\Samples\SampleApp              #
#                          _02\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH_LE #
#                          VEL\" -I "C:\Texas Instruments\ZStack-CC2530-2.3.0 #
#                          -1.4.0\Projects\zstack\Samples\SampleApp           #
#                          _02\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEV #
#                          EL\srf04\" -I "C:\Texas Instruments\ZStack-CC2530- #
#                          2.3.0-1.4.0\Projects\zstack\Samples\SampleApp      #
#                          _02\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEV #
#                          EL\srf04\SINGLE_CHIP\" -Ohz --require_prototypes   #
#    List file          =  C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4.0\Pro #
#                          jects\zstack\Samples\SampleApp                     #
#                          _02\CC2530DB\EndDeviceEB-Pro\List\SampleApp.lst    #
#    Object file        =  C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4.0\Pro #
#                          jects\zstack\Samples\SampleApp                     #
#                          _02\CC2530DB\EndDeviceEB-Pro\Obj\SampleApp.r51     #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-CC2530-2.3.0-1.4.0\Projects\zstack\Samples\SampleApp _02\Source\SampleApp.c
      1          /**************************************************************************************************
      2            Filename:       SampleApp.c
      3            Revised:        $Date: 2009-03-18 15:56:27 -0700 (Wed, 18 Mar 2009) $
      4            Revision:       $Revision: 19453 $
      5          
      6            Description:    Sample Application (no Profile).
      7          
      8          
      9            Copyright 2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41            This application isn't intended to do anything useful, it is
     42            intended to be a simple example of an application's structure.
     43          
     44            This application sends it's messages either as broadcast or
     45            broadcast filtered group messages.  The other (more normal)
     46            message addressing is unicast.  Most of the other sample
     47            applications are written to support the unicast message model.
     48          
     49            Key control:
     50              SW1:  Sends a flash command to all devices in Group 1.
     51              SW2:  Adds/Removes (toggles) this device in and out
     52                    of Group 1.  This will enable and disable the
     53                    reception of the flash command.
     54          *********************************************************************/
     55          
     56          /*********************************************************************
     57           * INCLUDES
     58           */
     59          #include "OSAL.h"
     60          #include "ZGlobals.h"
     61          #include "AF.h"
     62          #include "aps_groups.h"
     63          #include "ZDApp.h"
     64          
     65          #include "SampleApp.h"
     66          #include "SampleAppHw.h"
     67          
     68          #include "OnBoard.h"
     69          
     70          /* HAL */
     71          #include "hal_lcd.h"
     72          #include "hal_led.h"
     73          #include "hal_key.h"
     74          
     75          #include "MT_UART.h"
     76          #include "string.h"
     77          #include "hal_uart.h"
     78          #include "DataDeal.H"
     79          
     80          // This is the max byte count per OTA message.
     81          #if !defined( SERIAL_APP_TX_MAX )
     82          #define SERIAL_APP_TX_MAX  100
     83          #endif
     84          
     85          /*********************************************************************
     86           * MACROS
     87           */
     88          
     89          /*********************************************************************
     90           * CONSTANTS
     91           */
     92          
     93          /*********************************************************************
     94           * TYPEDEFS
     95           */
     96          
     97          /*********************************************************************
     98           * GLOBAL VARIABLES
     99           */
    100          
    101          // This list should be filled with Application specific Cluster IDs.
    102          const cId_t SampleApp_ClusterList[SAMPLEAPP_MAX_CLUSTERS] =
    103          {
    104            SAMPLEAPP_PERIODIC_CLUSTERID,
    105            SAMPLEAPP_FLASH_CLUSTERID
    106          };
    107          
    108          const SimpleDescriptionFormat_t SampleApp_SimpleDesc =
    109          {
    110            SAMPLEAPP_ENDPOINT,              //  int Endpoint;
    111            SAMPLEAPP_PROFID,                //  uint16 AppProfId[2];
    112            SAMPLEAPP_DEVICEID,              //  uint16 AppDeviceId[2];
    113            SAMPLEAPP_DEVICE_VERSION,        //  int   AppDevVer:4;
    114            SAMPLEAPP_FLAGS,                 //  int   AppFlags:4;
    115            SAMPLEAPP_MAX_CLUSTERS,          //  uint8  AppNumInClusters;
    116            (cId_t *)SampleApp_ClusterList,  //  uint8 *pAppInClusterList;
    117            SAMPLEAPP_MAX_CLUSTERS,          //  uint8  AppNumInClusters;
    118            (cId_t *)SampleApp_ClusterList   //  uint8 *pAppInClusterList;
    119          };
    120          
    121          // This is the Endpoint/Interface description.  It is defined here, but
    122          // filled-in in SampleApp_Init().  Another way to go would be to fill
    123          // in the structure here and make it a "const" (in code space).  The
    124          // way it's defined in this sample app it is define in RAM.
    125          endPointDesc_t SampleApp_epDesc;
    126          
    127          /*********************************************************************
    128           * EXTERNAL VARIABLES
    129           */
    130          
    131          /*********************************************************************
    132           * EXTERNAL FUNCTIONS
    133           */
    134          
    135          /*********************************************************************
    136           * LOCAL VARIABLES
    137           */
    138          uint8 SampleApp_TaskID;   // Task ID for internal task/event processing
    139                                    // This variable will be received when
    140                                    // SampleApp_Init() is called.
    141          devStates_t SampleApp_NwkState;
    142          
    143          uint8 SampleApp_TransID;  // This is the unique message ID (counter)
    144          
    145          afAddrType_t SampleApp_Periodic_DstAddr;
    146          afAddrType_t SampleApp_Flash_DstAddr;
    147          
    148          aps_Group_t SampleApp_Group;
    149          
    150          uint8 SampleAppPeriodicCounter = 0;
    151          uint8 SampleAppFlashCounter = 0;
    152          
    153          unsigned char RxBuf[SERIAL_APP_TX_MAX+1];
    154          byte recData[1];
    155          static uint8 SerialApp_TxLen;
    156          int httpCon1 = 0;
    157          int httpsend = 0;
    158          
    159          /*********************************************************************
    160           * LOCAL FUNCTIONS
    161           */
    162          void SampleApp_HandleKeys( uint8 shift, uint8 keys );
    163          void SampleApp_MessageMSGCB( afIncomingMSGPacket_t *pckt );
    164          void SampleApp_SendPeriodicMessage( void );
    165          void SampleApp_SendFlashMessage( uint16 flashTime );
    166          void rxCB(uint8 port,uint8 event);
    167          void Delay_ustt(uint8 Time);
    168          void DeviceControlManager(unsigned char* buff,int length);
    169          
    170          /*********************************************************************
    171           * NETWORK LAYER CALLBACKS
    172           */
    173          
    174          /*********************************************************************
    175           * PUBLIC FUNCTIONS
    176           */
    177          
    178          /*********************************************************************
    179           * @fn      SampleApp_Init
    180           *
    181           * @brief   Initialization function for the Generic App Task.
    182           *          This is called during initialization and should contain
    183           *          any application specific initialization (ie. hardware
    184           *          initialization/setup, table initialization, power up
    185           *          notificaiton ... ).
    186           *
    187           * @param   task_id - the ID assigned by OSAL.  This ID should be
    188           *                    used to send messages and set timers.
    189           *
    190           * @return  none
    191           */
    192          void SampleApp_Init( uint8 task_id )
    193          {
    194          
    195          
    196            SampleApp_TaskID = task_id;
    197            SampleApp_NwkState = DEV_INIT;
    198            SampleApp_TransID = 0;
    199            //MT_UartInit();
    200            //HalUARTWrite(0,"uart0 is ok\n",strlen("uart0 is ok\n"));
    201            
    202            halUARTCfg_t uartConfig;            //串口配置
    203            uartConfig.configured           = TRUE;              // 2x30 don't care - see uart driver.
    204            uartConfig.baudRate             = HAL_UART_BR_115200;       //波特路
    205            uartConfig.flowControl          = FALSE;
    206            uartConfig.flowControlThreshold = 64;   // 2x30 don't care - see uart driver.
    207            uartConfig.rx.maxBufSize        = 128;  // 2x30 don't care - see uart driver.
    208            uartConfig.tx.maxBufSize        = 128;  // 2x30 don't care - see uart driver.
    209            uartConfig.idleTimeout          = 6;    // 2x30 don't care - see uart driver.
    210            uartConfig.intEnable            = TRUE; // 2x30 don't care - see uart driver.
    211            uartConfig.callBackFunc         = rxCB;
    212           
    213            
    214           
    215            
    216            // Update the display
    217           #if defined(ZDO_COORDINATOR)
    218            
    219              HalUARTOpen (HAL_UART_PORT_0, &uartConfig); 
    220              HalUARTWrite(HAL_UART_PORT_0,"UartIni04 RR\n", sizeof("UartInitr OK\n"));  //测试串口
    221          
    222          #endif
    223              
    224            // Device hardware initialization can be added here or in main() (Zmain.c).
    225            // If the hardware is application specific - add it here.
    226            // If the hardware is other parts of the device add it in main().
    227          
    228           #if defined ( BUILD_ALL_DEVICES )
    229            // The "Demo" target is setup to have BUILD_ALL_DEVICES and HOLD_AUTO_START
    230            // We are looking at a jumper (defined in SampleAppHw.c) to be jumpered
    231            // together - if they are - we will start up a coordinator. Otherwise,
    232            // the device will start as a router.
    233            if ( readCoordinatorJumper() )
    234              zgDeviceLogicalType = ZG_DEVICETYPE_COORDINATOR;
    235            else
    236              zgDeviceLogicalType = ZG_DEVICETYPE_ROUTER;
    237          #endif // BUILD_ALL_DEVICES
    238          
    239          #if defined ( HOLD_AUTO_START )
    240            // HOLD_AUTO_START is a compile option that will surpress ZDApp
    241            //  from starting the device and wait for the application to
    242            //  start the device.
    243            ZDOInitDevice(0);
    244          #endif
    245          
    246            // Setup for the periodic message's destination address
    247            // Broadcast to everyone     协调器给终端发送数据
    248            SampleApp_Periodic_DstAddr.addrMode = (afAddrMode_t)AddrBroadcast;
    249            SampleApp_Periodic_DstAddr.endPoint = SAMPLEAPP_ENDPOINT;
    250            SampleApp_Periodic_DstAddr.addr.shortAddr = 0xFFFF;
    251          
    252            // Setup for the flash command's destination address - Group 1
    253            //终端给协调器发送数据 以单播的方式
    254            SampleApp_Flash_DstAddr.addrMode = (afAddrMode_t)Addr16Bit;
    255            SampleApp_Flash_DstAddr.endPoint = SAMPLEAPP_ENDPOINT;
    256            SampleApp_Flash_DstAddr.addr.shortAddr = 0x0000;
    257          
    258            // Fill out the endpoint description.
    259            SampleApp_epDesc.endPoint = SAMPLEAPP_ENDPOINT;
    260            SampleApp_epDesc.task_id = &SampleApp_TaskID;
    261            SampleApp_epDesc.simpleDesc
    262                      = (SimpleDescriptionFormat_t *)&SampleApp_SimpleDesc;
    263            SampleApp_epDesc.latencyReq = noLatencyReqs;
    264          
    265            // Register the endpoint description with the AF
    266            afRegister( &SampleApp_epDesc );
    267          
    268            // Register for all key events - This app will handle all key events
    269            RegisterForKeys( SampleApp_TaskID );
    270          /*
    271            // By default, all devices start out in Group 1
    272            SampleApp_Group.ID = 0x0001;
    273            osal_memcpy( SampleApp_Group.name, "Group 1", 7  );
    274            aps_AddGroup( SAMPLEAPP_ENDPOINT, &SampleApp_Group );
    275            */
    276          
    277          #if defined ( LCD_SUPPORTED )
    278            HalLcdWriteString( "SampleApp", HAL_LCD_LINE_1 );
    279          #endif
    280          }
    281          
    282          /*********************************************************************
    283           * @fn      SampleApp_ProcessEvent
    284           *
    285           * @brief   Generic Application Task event processor.  This function
    286           *          is called to process all events for the task.  Events
    287           *          include timers, messages and any other user defined events.
    288           *
    289           * @param   task_id  - The OSAL assigned task ID.
    290           * @param   events - events to process.  This is a bit map and can
    291           *                   contain more than one event.
    292           *
    293           * @return  none
    294           */
    295          uint16 SampleApp_ProcessEvent( uint8 task_id, uint16 events )
    296          {
    297            afIncomingMSGPacket_t *MSGpkt;
    298            (void)task_id;  // Intentionally unreferenced parameter
    299          
    300            if ( events & SYS_EVENT_MSG )
    301            {
    302              MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( SampleApp_TaskID );
    303              while ( MSGpkt )
    304              {
    305                switch ( MSGpkt->hdr.event )
    306                {
    307                  // Received when a key is pressed
    308                  case KEY_CHANGE:
    309                    SampleApp_HandleKeys( ((keyChange_t *)MSGpkt)->state, ((keyChange_t *)MSGpkt)->keys );
    310                    break;
    311          
    312                  // Received when a messages is received (OTA) for this endpoint
    313                  case AF_INCOMING_MSG_CMD:
    314                    SampleApp_MessageMSGCB( MSGpkt );
    315                    break;
    316          
    317                  // Received whenever the device changes state in the network
    318                  case ZDO_STATE_CHANGE:
    319                    SampleApp_NwkState = (devStates_t)(MSGpkt->hdr.status);
    320                    if ( (SampleApp_NwkState == DEV_ZB_COORD)
    321                        || (SampleApp_NwkState == DEV_ROUTER)
    322                        || (SampleApp_NwkState == DEV_END_DEVICE) )
    323                    {
    324                      // Start sending the periodic message in a regular interval.
    325                      osal_start_timerEx( SampleApp_TaskID,
    326                                        SAMPLEAPP_SEND_PERIODIC_MSG_EVT,
    327                                        SAMPLEAPP_SEND_PERIODIC_MSG_TIMEOUT );
    328                    }
    329                    else
    330                    {
    331                      // Device is no longer in the network
    332                    }
    333                    break;
    334          
    335                  default:
    336                    break;
    337                }
    338          
    339                // Release the memory
    340                osal_msg_deallocate( (uint8 *)MSGpkt );
    341          
    342                // Next - if one is available
    343                MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( SampleApp_TaskID );
    344              }
    345          
    346              // return unprocessed events
    347              return (events ^ SYS_EVENT_MSG);
    348            }
    349          
    350            // Send a message out - This event is generated by a timer
    351            //  (setup in SampleApp_Init()).
    352            if ( events & SAMPLEAPP_SEND_PERIODIC_MSG_EVT )
    353            { 
    354              if(zgDeviceLogicalType == ZG_DEVICETYPE_COORDINATOR)
    355                   //Send the periodic message
    356                  SampleApp_SendPeriodicMessage();
    357              else if(zgDeviceLogicalType == ZG_DEVICETYPE_ENDDEVICE)
    358                   SampleApp_SendFlashMessage(0x0000);
    359          
    360               //Setup to send message again in normal period (+ a little jitter)
    361              osal_start_timerEx( SampleApp_TaskID, SAMPLEAPP_SEND_PERIODIC_MSG_EVT,
    362                  (SAMPLEAPP_SEND_PERIODIC_MSG_TIMEOUT + (osal_rand() & 0x00FF)) );
    363          
    364              // return unprocessed events
    365              return (events ^ SAMPLEAPP_SEND_PERIODIC_MSG_EVT);
    366            }
    367          
    368            // Discard unknown events
    369            return 0;
    370          }
    371          
    372          /*********************************************************************
    373           * Event Generation Functions
    374           */
    375          /*********************************************************************
    376           * @fn      SampleApp_HandleKeys
    377           *
    378           * @brief   Handles all key events for this device.
    379           *
    380           * @param   shift - true if in shift/alt.
    381           * @param   keys - bit field for key events. Valid entries:
    382           *                 HAL_KEY_SW_2
    383           *                 HAL_KEY_SW_1
    384           *
    385           * @return  none
    386           */
    387          void SampleApp_HandleKeys( uint8 shift, uint8 keys )
    388          {
    389            (void)shift;  // Intentionally unreferenced parameter
    390            
    391            if ( keys & HAL_KEY_SW_1 )
    392            {
    393              /* This key sends the Flash Command is sent to Group 1.
    394               * This device will not receive the Flash Command from this
    395               * device (even if it belongs to group 1).
    396               */
    397              SampleApp_SendFlashMessage( SAMPLEAPP_FLASH_DURATION );
    398            }
    399          
    400            if ( keys & HAL_KEY_SW_2 )
    401            {
    402              /* The Flashr Command is sent to Group 1.
    403               * This key toggles this device in and out of group 1.
    404               * If this device doesn't belong to group 1, this application
    405               * will not receive the Flash command sent to group 1.
    406               */
    407              aps_Group_t *grp;
    408              grp = aps_FindGroup( SAMPLEAPP_ENDPOINT, SAMPLEAPP_FLASH_GROUP );
    409              if ( grp )
    410              {
    411                // Remove from the group
    412                aps_RemoveGroup( SAMPLEAPP_ENDPOINT, SAMPLEAPP_FLASH_GROUP );
    413              }
    414              else
    415              {
    416                // Add to the flash group
    417                aps_AddGroup( SAMPLEAPP_ENDPOINT, &SampleApp_Group );
    418              }
    419            }
    420          }
    421          
    422          /*********************************************************************
    423           * LOCAL FUNCTIONS
    424           */
    425          
    426          /*********************************************************************
    427           * @fn      SampleApp_MessageMSGCB
    428           *
    429           * @brief   Data message processor callback.  This function processes
    430           *          any incoming data - probably from other devices.  So, based
    431           *          on cluster ID, perform the intended action.
    432           *
    433           * @param   none
    434           *
    435           * @return  none
    436           */
    437          void SampleApp_MessageMSGCB( afIncomingMSGPacket_t *pkt )
    438          {
    439            uint16 flashTime;
                          ^
Warning[Pe177]: variable "flashTime" was declared but never referenced
    440          
    441            switch ( pkt->clusterId )
    442            {
    443              //终端节点收到来自协调器的消息
    444              case SAMPLEAPP_PERIODIC_CLUSTERID:
    445                //HalUARTWrite(0,(pkt)->cmd.Data,(pkt->cmd).DataLength);
    446                   DeviceControlManager((pkt)->cmd.Data,(pkt->cmd).DataLength);
    447                   break;
    448                
    449              //协调器收到来自终端节的消息
    450              case SAMPLEAPP_FLASH_CLUSTERID:
    451                HalUARTWrite(0,(pkt)->cmd.Data,(pkt->cmd).DataLength);
    452                break;
    453            }
    454          }
    455          
    456          /*********************************************************************
    457           * @fn      SampleApp_SendPeriodicMessage
    458           *
    459           * @brief   Send the periodic message.
    460           *
    461           * @param   none
    462           *
    463           * @return  none
    464           */
    465          void SampleApp_SendPeriodicMessage( void )
    466          {
    467            //uint8 *buff = "I am coordinator device\n";
    468            
    469            //if ( AF_DataRequest( &SampleApp_Periodic_DstAddr, &SampleApp_epDesc,
    470            //                     SAMPLEAPP_PERIODIC_CLUSTERID,
    471            //                    strlen(buff),
    472            //                     buff,
    473            //                     &SampleApp_TransID,
    474            //                     AF_DISCV_ROUTE,
    475            //                     AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
    476            //{
    477           // }
    478            //else
    479            //{
    480              // Error occurred in request to send.
    481            //}
    482          }
    483          
    484          /*********************************************************************
    485           * @fn      SampleApp_SendFlashMessage
    486           *
    487           * @brief   Send the flash message to group 1.
    488           *
    489           * @param   flashTime - in milliseconds
    490           *
    491           * @return  none
    492           */
    493          void SampleApp_SendFlashMessage( uint16 flashTime )
    494          {
    495              uint8 tempH[4],beam[5],mq[5]; //温湿度,光照，烟雾
    496              getDHT11(tempH);              //获取温湿度
    497              getMQ_2(mq);                  //获取MQ_2
    498              getLightSensor(beam);         //获取光敏电阻传感器数据
    499              
    500              uint8 *buffer;
    501              *buffer = '1';         //消息头
                      ^
Warning[Pe549]: variable "buffer" is used before its value is set
    502              *(buffer+1) = ' ';
    503              *(buffer+2) = tempH[0];
    504              *(buffer+3) = tempH[1];
    505              *(buffer+4) = ' ';
    506              *(buffer+5) = tempH[2];
    507              *(buffer+6) = tempH[3];
    508              *(buffer+7) = ' ';
    509              *(buffer+8) = mq[0];
    510              *(buffer+9) = mq[1];
    511              *(buffer+10) = mq[2];
    512              *(buffer+11) = ' ';
    513              *(buffer+12) = beam[0];
    514              *(buffer+13) = beam[1];
    515              *(buffer+14) = beam[2];
    516              *(buffer+15) = beam[3];
    517              *(buffer+16) = beam[4];
    518              *(buffer+17) = '\n';
    519              *(buffer+18) = '\0';
    520            
    521              
    522              //HalUARTWrite(HAL_UART_PORT_0,tempH, strlen(tempH));  //测试串口
    523            
    524            if ( AF_DataRequest( &SampleApp_Flash_DstAddr, &SampleApp_epDesc,
    525                                 SAMPLEAPP_FLASH_CLUSTERID,
    526                                 strlen(buffer),
                                               ^
Warning[Pe167]: argument of type "unsigned char *" is incompatible with
          parameter of type "char const *"
    527                                 buffer,
    528                                 &SampleApp_TransID,
    529                                 AF_DISCV_ROUTE,
    530                                 AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
    531            {
    532            }
    533            else
    534            {
    535              // Error occurred in request to send.
    536            }
    537          }
    538          
    539          void delay1s(unsigned char n)   //误差 -0.25us
                      ^
Error[Pa045]: function "delay1s" has no prototype
    540          {
    541              unsigned char i,c,b,a;
    542                for(i=0;i<n;i++){
    543                  for(c=151;c>0;c--)
    544                      for(b=97;b>0;b--)
    545                          for(a=44;a>0;a--);
    546                }
    547              
    548          }
    549          
    550          static void rxCB(uint8 port,uint8 event)
    551          {   
    552            if ((event & (HAL_UART_RX_FULL | HAL_UART_RX_ABOUT_FULL | HAL_UART_RX_TIMEOUT)) &&
    553          #if SERIAL_APP_LOOPBACK
    554                (SerialApp_TxLen < SERIAL_APP_TX_MAX))
    555          #else
    556                !SerialApp_TxLen)
    557          #endif
    558            { 
    559                  uint16 len = Hal_UART_RxBufLen(HAL_UART_PORT_0);            //获取串口数据长度
    560                  SerialApp_TxLen = HalUARTRead(HAL_UART_PORT_0, RxBuf,len); //保持串口读取
    561          
    562                 
    563                  
    564                  //协调器串口接收ESP的控制消息，转发给终端节点
    565                  if ( AF_DataRequest( &SampleApp_Periodic_DstAddr, &SampleApp_epDesc,
    566                                 SAMPLEAPP_PERIODIC_CLUSTERID,
    567                                 strlen(RxBuf),
                                               ^
Warning[Pe167]: argument of type "unsigned char *" is incompatible with
          parameter of type "char const *"
    568                                 RxBuf,
    569                                 &SampleApp_TransID,
    570                                 AF_DISCV_ROUTE,
    571                                 AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
    572                  {
    573                  }
    574                  else
    575                  {
    576                      // Error occurred in request to send.
    577                  }
    578                  
    579                SerialApp_TxLen=0;
    580              }
    581          }
    582          
    583          void Delay_ustt(uint8 Time) //us延时
    584          {
    585              unsigned char i;
    586              for(i=0;i<Time;i++)
    587              {
    588                  MicroWait(1);    //协议栈自带延时 1us 
    589              }
    590          }
    591          
    592          //电器控制
    593          void DeviceControlManager(unsigned char* buff,int length)
    594          {
    595            
    596            if(strstr(buff,"eep_open")!=NULL){
                             ^
Warning[Pe167]: argument of type "unsigned char *" is incompatible with
          parameter of type "char const *"
    597                  controlBeep(BEEP_ON);
    598            }else if(strstr(buff,"eep_close")!=NULL){
                                   ^
Warning[Pe167]: argument of type "unsigned char *" is incompatible with
          parameter of type "char const *"
    599                  controlBeep(BEEP_OFF);
    600            }else if(strstr(buff,"elay_open")!=NULL){
                                   ^
Warning[Pe167]: argument of type "unsigned char *" is incompatible with
          parameter of type "char const *"
    601                  controlRelay(RELAY_ON);
    602            }else if(strstr(buff,"elay_close")!=NULL){
                                   ^
Warning[Pe167]: argument of type "unsigned char *" is incompatible with
          parameter of type "char const *"
    603                  controlRelay(RELAY_OFF);
    604            }else if(strstr(buff,"c_open")!=NULL){
                                   ^
Warning[Pe167]: argument of type "unsigned char *" is incompatible with
          parameter of type "char const *"
    605                  ControlDCMotor(0,0);
    606            }else if(strstr(buff,"c_close")!=NULL){
                                   ^
Warning[Pe167]: argument of type "unsigned char *" is incompatible with
          parameter of type "char const *"
    607                  ControlDCMotor(1,1);
    608            }
    609          }
    610          
    611          /*********************************************************************
    612          *********************************************************************/

Errors: 1
Warnings: 10
